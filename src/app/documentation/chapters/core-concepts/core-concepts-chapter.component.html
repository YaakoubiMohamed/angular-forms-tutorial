<div class="documentation-content" (click)="onAnchorClick($event)">
  <h1>Concepts Fondamentaux</h1>

  <p class="subtitle">Angular Forms - Approches Fondamentales</p>

  <div class="breadcrumb">
    <a routerLink="/documentation">← Retour à l'Index</a> | 
    <a routerLink="/documentation/form-classes">Suivant : Classes de Formulaires →</a>
  </div>

  <hr>

  <h2>Table des Matières</h2>
  <ul>
    <li><a href="#aperçu">Aperçu</a></li>
    <li><a href="#reactive-forms">Reactive Forms</a></li>
    <li><a href="#template-driven-forms">Template-Driven Forms</a></li>
    <li><a href="#comparaison">Comparaison</a></li>
    <li><a href="#guide-de-décision">Guide de Décision</a></li>
  </ul>

  <hr>

  <h2 id="aperçu">Aperçu</h2>
  <p>Angular propose deux paradigmes distincts pour la construction de formulaires, chacun avec sa propre philosophie, ses forces et ses cas d'utilisation idéaux. Comprendre ces approches est fondamental pour prendre des décisions architecturales éclairées.</p>

  <hr>

  <h2 id="reactive-forms">Reactive Forms</h2>

  <h3>Définition</h3>
  <p>Les Reactive Forms représentent une approche <strong>pilotée par le modèle</strong> où la structure du formulaire est explicitement définie dans le code TypeScript. Le terme "réactif" dérive de la programmation réactive — un paradigme centré sur les flux de données asynchrones et la propagation des changements.</p>

  <h3>Caractéristiques Clés</h3>

  <h4>1. Immutabilité</h4>
  <p>Chaque changement de valeur produit un nouvel objet d'état plutôt que de muter l'existant. Cela facilite :</p>
  <ul>
    <li><strong>Détection des changements</strong> : Angular peut détecter les changements par comparaison de référence</li>
    <li><strong>Débogage</strong> : Facile de suivre l'historique des états</li>
    <li><strong>Débogage temporel</strong> : Les états précédents sont préservés</li>
  </ul>

  <pre><code class="language-typescript">// Chaque setValue crée un nouvel état
form.get('email')?.setValue('nouveau@email.com');
// L'état original est immuable, un nouvel état est émis</code></pre>

  <h4>2. Accès Synchrone</h4>
  <p>La valeur du formulaire est accessible instantanément sans attendre les callbacks :</p>

  <pre><code class="language-typescript">// Accès direct et synchrone à la valeur
const emailValue = this.form.get('email')?.value;
const isValid = this.form.valid;
const allErrors = this.form.errors;</code></pre>

  <h4>3. Basé sur les Observables</h4>
  <p>Les changements sont émis via des flux RxJS, permettant des patterns réactifs puissants :</p>

  <pre><code class="language-typescript">this.form.get('email')?.valueChanges.pipe(
  debounceTime(300),
  distinctUntilChanged(),
  switchMap(email => this.validateEmail(email))
).subscribe(result => {
  console.log('Résultat de validation:', result);
});</code></pre>

  <h3>Exemple d'Implémentation</h3>
  <pre><code class="language-typescript">import { Component, inject } from '@angular/core';
import { ReactiveFormsModule, FormBuilder, Validators } from '@angular/forms';

@Component({
  selector: 'app-login',
  standalone: true,
  imports: [ReactiveFormsModule],
  template: `
    &lt;form [formGroup]="loginForm" (ngSubmit)="onSubmit()"&gt;
      &lt;input formControlName="email" placeholder="Email"&gt;
      &lt;input formControlName="password" type="password" placeholder="Mot de passe"&gt;
      &lt;button type="submit" [disabled]="loginForm.invalid"&gt;Connexion&lt;/button&gt;
    &lt;/form&gt;
  `
})
export class LoginComponent {
  private fb = inject(FormBuilder);
  
  loginForm = this.fb.group({
    email: ['', [Validators.required, Validators.email]],
    password: ['', [Validators.required, Validators.minLength(8)]]
  });
  
  onSubmit() {
    if (this.loginForm.valid) {
      console.log('Données du formulaire:', this.loginForm.value);
    }
  }
}</code></pre>

  <hr>

  <h2 id="template-driven-forms">Template-Driven Forms</h2>

  <h3>Définition</h3>
  <p>Les Template-Driven Forms représentent une approche <strong>pilotée par le template</strong> où la structure du formulaire est définie dans le template HTML en utilisant des directives. Angular génère automatiquement le modèle de formulaire sous-jacent.</p>

  <h3>Caractéristiques Clés</h3>

  <h4>1. Simplicité du Template</h4>
  <p>La logique du formulaire est principalement dans le HTML :</p>

  <pre><code class="language-html">&lt;form #userForm="ngForm" (ngSubmit)="onSubmit(userForm)"&gt;
  &lt;input name="email" [(ngModel)]="user.email" required email&gt;
  &lt;input name="password" [(ngModel)]="user.password" required minlength="8"&gt;
  &lt;button type="submit" [disabled]="userForm.invalid"&gt;Envoyer&lt;/button&gt;
&lt;/form&gt;</code></pre>

  <h4>2. Two-Way Binding Automatique</h4>
  <p>Les changements sont automatiquement synchronisés entre le modèle et la vue :</p>

  <pre><code class="language-typescript">@Component({...})
export class UserComponent {
  user = {
    email: '',
    password: ''
  };
  
  // user.email est automatiquement mis à jour
  // quand l'utilisateur tape dans l'input
}</code></pre>

  <h4>3. Moins de Code TypeScript</h4>
  <p>Le composant reste simple :</p>

  <pre><code class="language-typescript">import { Component } from '@angular/core';
import { FormsModule, NgForm } from '@angular/forms';

@Component({
  selector: 'app-contact',
  standalone: true,
  imports: [FormsModule],
  template: `
    &lt;form #contactForm="ngForm" (ngSubmit)="onSubmit(contactForm)"&gt;
      &lt;input name="name" [(ngModel)]="contact.name" required&gt;
      &lt;input name="email" [(ngModel)]="contact.email" required email&gt;
      &lt;textarea name="message" [(ngModel)]="contact.message"&gt;&lt;/textarea&gt;
      &lt;button type="submit"&gt;Envoyer&lt;/button&gt;
    &lt;/form&gt;
  `
})
export class ContactComponent {
  contact = { name: '', email: '', message: '' };
  
  onSubmit(form: NgForm) {
    if (form.valid) {
      console.log('Contact:', this.contact);
    }
  }
}</code></pre>

  <hr>

  <h2 id="comparaison">Comparaison</h2>

  <h3>Tableau Comparatif</h3>
  <table class="comparison-table">
    <thead>
      <tr>
        <th>Aspect</th>
        <th>Reactive Forms</th>
        <th>Template-Driven Forms</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><strong>Définition du modèle</strong></td>
        <td>Dans le composant (TypeScript)</td>
        <td>Dans le template (HTML)</td>
      </tr>
      <tr>
        <td><strong>Création du modèle</strong></td>
        <td>Explicite (développeur)</td>
        <td>Implicite (Angular)</td>
      </tr>
      <tr>
        <td><strong>Flux de données</strong></td>
        <td>Observable (RxJS)</td>
        <td>Événementiel (ngModel)</td>
      </tr>
      <tr>
        <td><strong>Mutabilité</strong></td>
        <td>Immuable</td>
        <td>Mutable</td>
      </tr>
      <tr>
        <td><strong>Validation</strong></td>
        <td>Fonctions dans le code</td>
        <td>Attributs HTML</td>
      </tr>
      <tr>
        <td><strong>Testabilité</strong></td>
        <td>Excellente (sans DOM)</td>
        <td>Nécessite le DOM</td>
      </tr>
      <tr>
        <td><strong>Formulaires dynamiques</strong></td>
        <td>Excellent support</td>
        <td>Support limité</td>
      </tr>
      <tr>
        <td><strong>Courbe d'apprentissage</strong></td>
        <td>Plus raide</td>
        <td>Plus douce</td>
      </tr>
      <tr>
        <td><strong>Verbosité</strong></td>
        <td>Plus de code</td>
        <td>Moins de code</td>
      </tr>
      <tr>
        <td><strong>Typage</strong></td>
        <td>Fort (TypeScript)</td>
        <td>Faible</td>
      </tr>
    </tbody>
  </table>

  <h3>Quand Utiliser Chaque Approche</h3>

  <h4>Utilisez Reactive Forms quand :</h4>
  <ul>
    <li>✅ Le formulaire a une logique complexe</li>
    <li>✅ Vous avez besoin de validation croisée entre champs</li>
    <li>✅ Les champs sont ajoutés/supprimés dynamiquement</li>
    <li>✅ Vous voulez des tests unitaires sans DOM</li>
    <li>✅ Vous utilisez la stratégie OnPush</li>
    <li>✅ Vous intégrez avec un state management (NgRx)</li>
  </ul>

  <h4>Utilisez Template-Driven Forms quand :</h4>
  <ul>
    <li>✅ Le formulaire est simple (login, contact)</li>
    <li>✅ Peu de logique de validation</li>
    <li>✅ Prototypage rapide</li>
    <li>✅ Équipe familière avec AngularJS</li>
    <li>✅ Formulaires statiques sans champs dynamiques</li>
  </ul>

  <hr>

  <h2 id="guide-de-décision">Guide de Décision</h2>
  <div class="decision-tree">
    <p><strong>Le formulaire est-il simple ? (&lt; 5 champs, validation basique)</strong></p>
    <ul>
      <li><strong>OUI</strong> → Avez-vous besoin de tests sans DOM ?
        <ul>
          <li><strong>OUI</strong> → REACTIVE FORMS</li>
          <li><strong>NON</strong> → TEMPLATE-DRIVEN (Acceptable)</li>
        </ul>
      </li>
      <li><strong>NON</strong> → REACTIVE FORMS (Recommandé)</li>
    </ul>
  </div>

  <hr>

  <div class="footer-navigation">
    <a routerLink="/documentation">← Retour à l'Index</a> | 
    <a routerLink="/documentation/form-classes">Suivant : Classes de Formulaires →</a>
  </div>

</div>









