<div class="chapter-content">
  <h1>Programmation RÃ©active</h1>

  <div style="text-align: center;">
    <p><strong>Angular Forms - RxJS et Observables</strong></p>
    <p>
      <a routerLink="/documentation/validation">â† Validation</a> | 
      <a routerLink="/documentation/api-reference">Index</a> | 
      <a routerLink="/documentation/modules">Suivant : Modules â†’</a>
    </p>
  </div>

  <hr>

  <h2 id="table-des-matieres">Table des MatiÃ¨res</h2>

  <ul>
    <li><a href="#apercu">AperÃ§u</a></li>
    <li><a href="#valuechanges">valueChanges</a></li>
    <li><a href="#statuschanges">statusChanges</a></li>
    <li><a href="#operateurs-rxjs-essentiels">OpÃ©rateurs RxJS Essentiels</a></li>
    <li><a href="#patterns-avances">Patterns AvancÃ©s</a></li>
    <li><a href="#exemples-pratiques">Exemples Pratiques</a></li>
  </ul>

  <hr>

  <h2 id="apercu">AperÃ§u</h2>

  <p>Angular Forms s'intÃ¨gre parfaitement avec RxJS grÃ¢ce aux Observables <code>valueChanges</code> et <code>statusChanges</code>.</p>

  <pre><code class="language-typescript">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    FLUX RÃ‰ACTIF                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ Saisie  â”‚  â”€â”€â”€â–¶  â”‚ FormControl â”‚  â”€â”€â”€â–¶  â”‚ Observable  â”‚
    â”‚ Clavier â”‚        â”‚             â”‚        â”‚             â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚                      â”‚
                              â–¼                      â–¼
                       valueChanges           OpÃ©rateurs RxJS
                       statusChanges          (map, filter, etc.)
                              â”‚                      â”‚
                              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                         â”‚
                                         â–¼
                              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                              â”‚ Actions RÃ©actives   â”‚
                              â”‚ â€¢ Recherche API     â”‚
                              â”‚ â€¢ Mise Ã  jour UI    â”‚
                              â”‚ â€¢ Validation        â”‚
                              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre>

  <hr>

  <h2 id="valuechanges">valueChanges</h2>

  <h3>DÃ©finition</h3>

  <p><code>valueChanges</code> est un Observable qui Ã©met la nouvelle valeur Ã  chaque modification du contrÃ´le.</p>

  <h3>Syntaxe de Base</h3>

  <pre><code class="language-typescript">import {{ '{' }} FormControl {{ '}' }} from '@angular/forms';

const searchControl = new FormControl('');

// S'abonner aux changements
searchControl.valueChanges.subscribe(value => {{ '{' }}
  console.log('Nouvelle valeur :', value);
{{ '}' }});</code></pre>

  <h3>Sur FormControl</h3>

  <pre><code class="language-typescript">const email = new FormControl('');

email.valueChanges.subscribe(value => {{ '{' }}
  console.log('Email :', value);
{{ '}' }});</code></pre>

  <h3>Sur FormGroup</h3>

  <pre><code class="language-typescript">const form = new FormGroup({{ '{' }}
  firstName: new FormControl(''),
  lastName: new FormControl('')
{{ '}' }});

// Ã‰couter tout le groupe
form.valueChanges.subscribe(value => {{ '{' }}
  console.log('Formulaire :', value);
  // {{ '{' }} firstName: '...', lastName: '...' {{ '}' }}
{{ '}' }});

// Ã‰couter un contrÃ´le spÃ©cifique
form.get('firstName')?.valueChanges.subscribe(value => {{ '{' }}
  console.log('PrÃ©nom :', value);
{{ '}' }});</code></pre>

  <h3>Sur FormArray</h3>

  <pre><code class="language-typescript">const items = new FormArray([
  new FormControl(''),
  new FormControl('')
]);

items.valueChanges.subscribe(values => {{ '{' }}
  console.log('Tous les items :', values);
  // ['valeur1', 'valeur2']
{{ '}' }});</code></pre>

  <hr>

  <h2 id="statuschanges">statusChanges</h2>

  <h3>DÃ©finition</h3>

  <p><code>statusChanges</code> est un Observable qui Ã©met le statut de validation Ã  chaque changement.</p>

  <h3>Valeurs Possibles</h3>

  <table>
    <thead>
      <tr>
        <th>Statut</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>'VALID'</code></td>
        <td>Toutes les validations passent</td>
      </tr>
      <tr>
        <td><code>'INVALID'</code></td>
        <td>Au moins une validation Ã©choue</td>
      </tr>
      <tr>
        <td><code>'PENDING'</code></td>
        <td>Validation asynchrone en cours</td>
      </tr>
      <tr>
        <td><code>'DISABLED'</code></td>
        <td>Le contrÃ´le est dÃ©sactivÃ©</td>
      </tr>
    </tbody>
  </table>

  <h3>Exemple</h3>

  <pre><code class="language-typescript">const email = new FormControl('', [
  Validators.required,
  Validators.email
], [
  asyncEmailValidator
]);

email.statusChanges.subscribe(status => {{ '{' }}
  switch (status) {{ '{' }}
    case 'VALID':
      console.log('âœ… Email valide');
      break;
    case 'INVALID':
      console.log('âŒ Email invalide');
      break;
    case 'PENDING':
      console.log('â³ VÃ©rification en cours...');
      break;
    case 'DISABLED':
      console.log('ğŸš« Champ dÃ©sactivÃ©');
      break;
  {{ '}' }}
{{ '}' }});</code></pre>

  <hr>

  <h2 id="operateurs-rxjs-essentiels">OpÃ©rateurs RxJS Essentiels</h2>

  <h3>debounceTime</h3>

  <p>Attend un dÃ©lai aprÃ¨s la derniÃ¨re Ã©mission avant de transmettre.</p>

  <pre><code class="language-typescript">import {{ '{' }} debounceTime {{ '}' }} from 'rxjs/operators';

searchControl.valueChanges.pipe(
  debounceTime(300)  // Attend 300ms
).subscribe(value => {{ '{' }}
  this.performSearch(value);
{{ '}' }});</code></pre>

  <h3>distinctUntilChanged</h3>

  <p>Ã‰met uniquement si la valeur est diffÃ©rente de la prÃ©cÃ©dente.</p>

  <pre><code class="language-typescript">import {{ '{' }} distinctUntilChanged {{ '}' }} from 'rxjs/operators';

control.valueChanges.pipe(
  distinctUntilChanged()
).subscribe(value => {{ '{' }}
  // Ne rÃ©agit pas aux valeurs identiques consÃ©cutives
{{ '}' }});</code></pre>

  <h3>filter</h3>

  <p>Filtre les valeurs selon une condition.</p>

  <pre><code class="language-typescript">import {{ '{' }} filter {{ '}' }} from 'rxjs/operators';

searchControl.valueChanges.pipe(
  filter(value => value.length >= 3)  // Au moins 3 caractÃ¨res
).subscribe(value => {{ '{' }}
  this.search(value);
{{ '}' }});</code></pre>

  <h3>map</h3>

  <p>Transforme les valeurs Ã©mises.</p>

  <pre><code class="language-typescript">import {{ '{' }} map {{ '}' }} from 'rxjs/operators';

emailControl.valueChanges.pipe(
  map(value => value.toLowerCase().trim())
).subscribe(normalizedEmail => {{ '{' }}
  // Email normalisÃ©
{{ '}' }});</code></pre>

  <h3>switchMap</h3>

  <p>Annule la requÃªte prÃ©cÃ©dente et lance une nouvelle.</p>

  <pre><code class="language-typescript">import {{ '{' }} switchMap {{ '}' }} from 'rxjs/operators';

searchControl.valueChanges.pipe(
  debounceTime(300),
  distinctUntilChanged(),
  switchMap(query => this.searchService.search(query))
).subscribe(results => {{ '{' }}
  this.results = results;
{{ '}' }});</code></pre>

  <h3>tap</h3>

  <p>ExÃ©cute un effet secondaire sans modifier le flux.</p>

  <pre><code class="language-typescript">import {{ '{' }} tap {{ '}' }} from 'rxjs/operators';

control.valueChanges.pipe(
  tap(value => console.log('Valeur reÃ§ue :', value)),
  map(value => value.toUpperCase())
).subscribe(value => {{ '{' }}
  // Traitement
{{ '}' }});</code></pre>

  <h3>startWith</h3>

  <p>Ã‰met une valeur initiale avant les autres Ã©missions.</p>

  <pre><code class="language-typescript">import {{ '{' }} startWith {{ '}' }} from 'rxjs/operators';

control.valueChanges.pipe(
  startWith(control.value)  // Ã‰met la valeur initiale
).subscribe(value => {{ '{' }}
  // ReÃ§oit immÃ©diatement la valeur actuelle
{{ '}' }});</code></pre>

  <h3>combineLatest</h3>

  <p>Combine plusieurs Observables.</p>

  <pre><code class="language-typescript">import {{ '{' }} combineLatest {{ '}' }} from 'rxjs';

combineLatest([
  this.form.get('minPrice')!.valueChanges.pipe(startWith(0)),
  this.form.get('maxPrice')!.valueChanges.pipe(startWith(1000)),
  this.form.get('category')!.valueChanges.pipe(startWith('all'))
]).subscribe(([minPrice, maxPrice, category]) => {{ '{' }}
  this.filterProducts(minPrice, maxPrice, category);
{{ '}' }});</code></pre>

  <hr>

  <h2 id="patterns-avances">Patterns AvancÃ©s</h2>

  <h3>Recherche avec Autocomplete</h3>

  <pre><code class="language-typescript">@Component({{ '{' }}
  template: `
    &lt;input [formControl]="searchControl" placeholder="Rechercher..."&gt;
    &lt;div class="loading" *ngIf="isLoading"&gt;Chargement...&lt;/div&gt;
    &lt;ul class="results"&gt;
      &lt;li *ngFor="let result of results"&gt;{{ result.name }}&lt;/li&gt;
    &lt;/ul&gt;
  `
{{ '}' }})
export class AutocompleteComponent implements OnInit, OnDestroy {{ '{' }}
  searchControl = new FormControl('');
  results: any[] = [];
  isLoading = false;
  private destroy$ = new Subject&lt;void&gt;();
  
  constructor(private searchService: SearchService) {{ '{' }}}
  
  ngOnInit() {{ '{' }}
    this.searchControl.valueChanges.pipe(
      takeUntil(this.destroy$),
      debounceTime(300),
      distinctUntilChanged(),
      filter(term => term.length >= 2),
      tap(() => this.isLoading = true),
      switchMap(term => this.searchService.search(term).pipe(
        catchError(() => of([]))
      )),
      tap(() => this.isLoading = false)
    ).subscribe(results => {{ '{' }}
      this.results = results;
    {{ '}' }});
  {{ '}' }}
  
  ngOnDestroy() {{ '{' }}
    this.destroy$.next();
    this.destroy$.complete();
  {{ '}' }}
{{ '}' }}</code></pre>

  <h3>Sauvegarde Automatique</h3>

  <pre><code class="language-typescript">@Component({{ '{' }}
  template: `
    &lt;form [formGroup]="form"&gt;
      &lt;input formControlName="title" placeholder="Titre"&gt;
      &lt;textarea formControlName="content" placeholder="Contenu"&gt;&lt;/textarea&gt;
      &lt;span class="status"&gt;{{ saveStatus }}&lt;/span&gt;
    &lt;/form&gt;
  `
{{ '}' }})
export class AutoSaveComponent implements OnInit, OnDestroy {{ '{' }}
  form = new FormGroup({{ '{' }}
    title: new FormControl(''),
    content: new FormControl('')
  {{ '}' }});
  
  saveStatus = 'PrÃªt';
  private destroy$ = new Subject&lt;void&gt;();
  
  ngOnInit() {{ '{' }}
    this.form.valueChanges.pipe(
      takeUntil(this.destroy$),
      debounceTime(2000),
      distinctUntilChanged((a, b) => JSON.stringify(a) === JSON.stringify(b)),
      tap(() => this.saveStatus = 'Sauvegarde en cours...'),
      switchMap(value => this.save(value))
    ).subscribe({{ '{' }}
      next: () => this.saveStatus = 'SauvegardÃ© âœ“',
      error: () => this.saveStatus = 'Erreur de sauvegarde âœ—'
    {{ '}' }});
  {{ '}' }}
  
  private save(data: any): Observable&lt;any&gt; {{ '{' }}
    return this.http.post('/api/draft', data);
  {{ '}' }}
  
  ngOnDestroy() {{ '{' }}
    this.destroy$.next();
    this.destroy$.complete();
  {{ '}' }}
{{ '}' }}</code></pre>

  <h3>Validation Conditionnelle RÃ©active</h3>

  <pre><code class="language-typescript">@Component({{ '{' }}
  template: `
    &lt;form [formGroup]="form"&gt;
      &lt;select formControlName="contactMethod"&gt;
        &lt;option value="email"&gt;Email&lt;/option&gt;
        &lt;option value="phone"&gt;TÃ©lÃ©phone&lt;/option&gt;
      &lt;/select&gt;
      
      &lt;input formControlName="email" placeholder="Email" 
             *ngIf="contactMethod === 'email'"&gt;
      
      &lt;input formControlName="phone" placeholder="TÃ©lÃ©phone"
             *ngIf="contactMethod === 'phone'"&gt;
    &lt;/form&gt;
  `
{{ '}' }})
export class ConditionalValidationComponent implements OnInit {{ '{' }}
  form = new FormGroup({{ '{' }}
    contactMethod: new FormControl('email'),
    email: new FormControl(''),
    phone: new FormControl('')
  {{ '}' }});
  
  get contactMethod() {{ '{' }}
    return this.form.get('contactMethod')?.value;
  {{ '}' }}
  
  ngOnInit() {{ '{' }}
    this.form.get('contactMethod')!.valueChanges.subscribe(method => {{ '{' }}
      const emailControl = this.form.get('email')!;
      const phoneControl = this.form.get('phone')!;
      
      if (method === 'email') {{ '{' }}
        emailControl.setValidators([Validators.required, Validators.email]);
        phoneControl.clearValidators();
      {{ '}' }} else {{ '{' }}
        phoneControl.setValidators([Validators.required, Validators.pattern(/^\d{{ '{' }}10{{ '}' }}$/)]);
        emailControl.clearValidators();
      {{ '}' }}
      
      emailControl.updateValueAndValidity();
      phoneControl.updateValueAndValidity();
    {{ '}' }});
  {{ '}' }}
{{ '}' }}</code></pre>

  <h3>Synchronisation de Champs</h3>

  <pre><code class="language-typescript">@Component({{ '{' }}
  template: `
    &lt;form [formGroup]="form"&gt;
      &lt;input formControlName="username" placeholder="Nom d'utilisateur"&gt;
      &lt;input formControlName="slug" placeholder="URL slug" readonly&gt;
    &lt;/form&gt;
  `
{{ '}' }})
export class SlugSyncComponent implements OnInit {{ '{' }}
  form = new FormGroup({{ '{' }}
    username: new FormControl(''),
    slug: new FormControl('')
  {{ '}' }});
  
  ngOnInit() {{ '{' }}
    this.form.get('username')!.valueChanges.pipe(
      map(value => this.slugify(value))
    ).subscribe(slug => {{ '{' }}
      this.form.get('slug')!.setValue(slug, {{ '{' }} emitEvent: false {{ '}' }});
    {{ '}' }});
  {{ '}' }}
  
  private slugify(text: string): string {{ '{' }}
    return text
      .toLowerCase()
      .normalize('NFD')
      .replace(/[\u0300-\u036f]/g, '')
      .replace(/[^a-z0-9]+/g, '-')
      .replace(/^-|-$/g, '');
  {{ '}' }}
{{ '}' }}</code></pre>

  <hr>

  <h2 id="exemples-pratiques">Exemples Pratiques</h2>

  <h3>Filtrage en Temps RÃ©el</h3>

  <pre><code class="language-typescript">@Component({{ '{' }}
  template: `
    &lt;form [formGroup]="filterForm"&gt;
      &lt;input formControlName="search" placeholder="Rechercher..."&gt;
      &lt;select formControlName="category"&gt;
        &lt;option value=""&gt;Toutes catÃ©gories&lt;/option&gt;
        &lt;option value="electronics"&gt;Ã‰lectronique&lt;/option&gt;
        &lt;option value="clothing"&gt;VÃªtements&lt;/option&gt;
      &lt;/select&gt;
      &lt;input formControlName="minPrice" type="number" placeholder="Prix min"&gt;
      &lt;input formControlName="maxPrice" type="number" placeholder="Prix max"&gt;
    &lt;/form&gt;
    
    &lt;div class="products"&gt;
      &lt;div *ngFor="let product of filteredProducts$ | async"&gt;
        {{ product.name }} - {{ product.price }}â‚¬
      &lt;/div&gt;
    &lt;/div&gt;
  `
{{ '}' }})
export class ProductFilterComponent implements OnInit {{ '{' }}
  filterForm = new FormGroup({{ '{' }}
    search: new FormControl(''),
    category: new FormControl(''),
    minPrice: new FormControl(null),
    maxPrice: new FormControl(null)
  {{ '}' }});
  
  filteredProducts$!: Observable&lt;Product[]&gt;;
  
  constructor(private productService: ProductService) {{ '{' }}}
  
  ngOnInit() {{ '{' }}
    this.filteredProducts$ = this.filterForm.valueChanges.pipe(
      startWith(this.filterForm.value),
      debounceTime(200),
      switchMap(filters => this.productService.filter(filters))
    );
  {{ '}' }}
{{ '}' }}</code></pre>

  <h3>Formulaire Multi-Ã‰tapes avec Ã‰tat</h3>

  <pre><code class="language-typescript">@Component({{ '{' }}
  template: `
    &lt;div class="steps"&gt;
      &lt;div *ngFor="let step of steps; let i = index" 
           [class.completed]="stepStatus[i] === 'VALID'"
           [class.current]="currentStep === i"&gt;
        Ã‰tape {{ i + 1 }}
      &lt;/div&gt;
    &lt;/div&gt;
    
    &lt;form [formGroup]="forms[currentStep]"&gt;
      &lt;!-- Contenu dynamique de l'Ã©tape --&gt;
    &lt;/form&gt;
  `
{{ '}' }})
export class MultiStepFormComponent implements OnInit {{ '{' }}
  forms: FormGroup[] = [
    new FormGroup({{ '{' }} /* Ã©tape 1 */ {{ '}' }}),
    new FormGroup({{ '{' }} /* Ã©tape 2 */ {{ '}' }}),
    new FormGroup({{ '{' }} /* Ã©tape 3 */ {{ '}' }})
  ];
  
  steps = ['Informations', 'Contact', 'Confirmation'];
  currentStep = 0;
  stepStatus: string[] = [];
  
  ngOnInit() {{ '{' }}
    this.forms.forEach((form, index) => {{ '{' }}
      form.statusChanges.subscribe(status => {{ '{' }}
        this.stepStatus[index] = status;
      {{ '}' }});
    {{ '}' }});
  {{ '}' }}
{{ '}' }}</code></pre>

  <h3>Gestion de la MÃ©moire</h3>

  <pre><code class="language-typescript">@Component({{ '{' }}...{{ '}' }})
export class SafeFormComponent implements OnInit, OnDestroy {{ '{' }}
  private destroy$ = new Subject&lt;void&gt;();
  
  form = new FormGroup({{ '{' }}
    search: new FormControl('')
  {{ '}' }});
  
  ngOnInit() {{ '{' }}
    // Utiliser takeUntil pour Ã©viter les fuites de mÃ©moire
    this.form.get('search')!.valueChanges.pipe(
      takeUntil(this.destroy$),
      debounceTime(300)
    ).subscribe(value => {{ '{' }}
      this.search(value);
    {{ '}' }});
  {{ '}' }}
  
  ngOnDestroy() {{ '{' }}
    // ComplÃ©ter le Subject pour dÃ©sabonner tous les observables
    this.destroy$.next();
    this.destroy$.complete();
  {{ '}' }}
{{ '}' }}</code></pre>

  <hr>

  <h2 id="bonnes-pratiques">Bonnes Pratiques</h2>

  <h3>1. Toujours se DÃ©sabonner</h3>

  <pre><code class="language-typescript">// âœ… Utiliser takeUntil
private destroy$ = new Subject&lt;void&gt;();

ngOnInit() {{ '{' }}
  observable.pipe(takeUntil(this.destroy$)).subscribe();
{{ '}' }}

ngOnDestroy() {{ '{' }}
  this.destroy$.next();
  this.destroy$.complete();
{{ '}' }}

// âœ… Ou utiliser le pipe async dans le template
// {{ data$ | async }}</code></pre>

  <h3>2. Ã‰viter les Effets en Cascade</h3>

  <pre><code class="language-typescript">// âŒ Risque de boucle infinie
control1.valueChanges.subscribe(v => control2.setValue(v));
control2.valueChanges.subscribe(v => control1.setValue(v));

// âœ… Utiliser emitEvent: false
control1.valueChanges.subscribe(v => {{ '{' }}
  control2.setValue(v, {{ '{' }} emitEvent: false {{ '}' }});
{{ '}' }});</code></pre>

  <h3>3. Utiliser startWith pour la Valeur Initiale</h3>

  <pre><code class="language-typescript">// âœ… Obtenir la valeur initiale immÃ©diatement
control.valueChanges.pipe(
  startWith(control.value)
).subscribe(value => {{ '{' }}
  // ReÃ§oit la valeur initiale puis les changements
{{ '}' }});</code></pre>

  <hr>

  <div style="text-align: center;">
    <p>
      <a routerLink="/documentation/validation">â† Validation</a> | 
      <a routerLink="/documentation/api-reference">Index</a> | 
      <a routerLink="/documentation/modules">Suivant : Modules â†’</a>
    </p>
  </div>

  <hr>

  <p><em>Tutoriel Angular 20 Forms - Documentation de RÃ©fÃ©rence API</em></p>

</div>
