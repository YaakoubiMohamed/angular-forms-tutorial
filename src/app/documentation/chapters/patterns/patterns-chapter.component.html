<div class="chapter-content" (click)="onAnchorClick($event)">
  <h1>Angular Forms Patterns</h1>

  <div style="text-align: center; margin: 2rem 0;">
    <p><strong>Angular Forms - Design Patterns &amp; Best Practices</strong></p>
    <p>
      <a routerLink="/documentation/modules">← Modules</a> | 
      <a routerLink="/documentation">Index</a>
    </p>
  </div>

  <hr>

  <h2 id="table-of-contents">Table of Contents</h2>

  <ul>
    <li><a href="#overview">Overview</a></li>
    <li><a href="#two-way-binding-pattern">Two-Way Binding Pattern</a></li>
    <li><a href="#model-driven-pattern">Model-Driven Pattern</a></li>
    <li><a href="#immutability-pattern">Immutability Pattern</a></li>
    <li><a href="#dynamic-forms-pattern">Dynamic Forms Pattern</a></li>
    <li><a href="#multi-step-forms-pattern">Multi-Step Forms Pattern</a></li>
    <li><a href="#form-factory-pattern">Form Factory Pattern</a></li>
    <li><a href="#onpush-optimization">OnPush Optimization</a></li>
  </ul>

  <hr>

  <h2 id="overview">Overview</h2>

  <p>Understanding form patterns helps you choose the right approach for your application's complexity and requirements.</p>

  <div ngNonBindable><pre><code>┌─────────────────────────────────────────────────────────────────┐
│                   FORM PATTERNS SPECTRUM                         │
└─────────────────────────────────────────────────────────────────┘

  Simple ◄───────────────────────────────────────────────► Complex
     │                                                         │
     │  Two-Way Binding                                        │
     │  (ngModel)                                              │
     │       │                                                 │
     │       └─────► Model-Driven                              │
     │               (Reactive Forms)                          │
     │                    │                                    │
     │                    └─────► Dynamic Forms                │
     │                            (Config-Based)               │
     │                                 │                       │
     │                                 └─────► Form Factory    │
     │                                        (Reusable)       │
     └─────────────────────────────────────────────────────────┘</code></pre></div>

  <h3>Pattern Selection Guide</h3>

  <table>
    <thead>
      <tr>
        <th>Pattern</th>
        <th>Best For</th>
        <th>Complexity</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Two-Way Binding</td>
        <td>Simple forms, prototypes</td>
        <td>Low</td>
      </tr>
      <tr>
        <td>Model-Driven</td>
        <td>Standard business forms</td>
        <td>Medium</td>
      </tr>
      <tr>
        <td>Immutability</td>
        <td>State management integration</td>
        <td>Medium</td>
      </tr>
      <tr>
        <td>Dynamic Forms</td>
        <td>Configurable/runtime forms</td>
        <td>High</td>
      </tr>
      <tr>
        <td>Multi-Step</td>
        <td>Wizards, long forms</td>
        <td>High</td>
      </tr>
      <tr>
        <td>Form Factory</td>
        <td>Reusable form logic</td>
        <td>High</td>
      </tr>
    </tbody>
  </table>

  <hr>

  <h2 id="two-way-binding-pattern">Two-Way Binding Pattern</h2>

  <p>The simplest approach using <code>ngModel</code> for direct model synchronization.</p>

  <h3>Concept</h3>

  <div ngNonBindable><pre><code>┌──────────────────────────────────────────────────────────────┐
│                 TWO-WAY BINDING FLOW                          │
└──────────────────────────────────────────────────────────────┘

         Component                      Template
      ┌─────────────┐                ┌─────────────┐
      │   model =   │ ────────────►  │   &lt;input    │
      │   &lbrace; name:   │   Property     │   [(ngModel)]│
      │   'John' &rbrace;  │   Binding      │   ="model.  │
      │             │                │     name"&gt;  │
      │             │ ◄────────────  │             │
      │             │   Event        │             │
      │             │   Binding      │             │
      └─────────────┘                └─────────────┘
                      │          │
                      │ [(ngModel)] = [ngModel] + (ngModelChange)
                      │
                      ▼
            ┌─────────────────┐
            │  Model always   │
            │  equals view    │
            └─────────────────┘</code></pre></div>

  <h3>Implementation</h3>

  <div ngNonBindable><pre><code class="language-typescript">import &lbrace; Component &rbrace; from '&#64;angular/core';
import &lbrace; FormsModule &rbrace; from '&#64;angular/forms';

interface UserModel &lbrace;
  firstName: string;
  lastName: string;
  email: string;
  newsletter: boolean;
&rbrace;

&#64;Component(&lbrace;
  selector: 'app-simple-form',
  standalone: true,
  imports: [FormsModule],
  template: &#96;
    &lt;form #userForm="ngForm" (ngSubmit)="onSubmit()"&gt;
      &lt;div class="form-group"&gt;
        &lt;label&gt;First Name&lt;/label&gt;
        &lt;input 
          name="firstName" 
          [(ngModel)]="user.firstName" 
          required
          #firstName="ngModel"
        &gt;
        @if (firstName.invalid && firstName.touched) {
          &lt;span class="error"&gt;
            First name is required
          &lt;/span&gt;
        }
      &lt;/div&gt;
      
      &lt;div class="form-group"&gt;
        &lt;label&gt;Last Name&lt;/label&gt;
        &lt;input 
          name="lastName" 
          [(ngModel)]="user.lastName" 
          required
        &gt;
      &lt;/div&gt;
      
      &lt;div class="form-group"&gt;
        &lt;label&gt;Email&lt;/label&gt;
        &lt;input 
          name="email" 
          [(ngModel)]="user.email" 
          required 
          email
          type="email"
        &gt;
      &lt;/div&gt;
      
      &lt;div class="form-group"&gt;
        &lt;label&gt;
          &lt;input 
            type="checkbox" 
            name="newsletter" 
            [(ngModel)]="user.newsletter"
          &gt;
          Subscribe to newsletter
        &lt;/label&gt;
      &lt;/div&gt;
      
      &lt;button type="submit" [disabled]="userForm.invalid"&gt;
        Submit
      &lt;/button&gt;
      
      &lt;!-- Debug: Live model view --&gt;
      &lt;pre&gt;&lbrace;&lbrace; user | json &rbrace;&rbrace;&lt;/pre&gt;
    &lt;/form&gt;
  &#96;
&rbrace;)
export class SimpleFormComponent &lbrace;
  user: UserModel = &lbrace;
    firstName: '',
    lastName: '',
    email: '',
    newsletter: false
  &rbrace;;
  
  onSubmit() &lbrace;
    console.log('Submitting:', this.user);
    // Model is already synchronized
  &rbrace;
&rbrace;</code></pre></div>

  <h3>When to Use</h3>

  <p>✅ <strong>Good for:</strong></p>
  <ul>
    <li>Simple contact forms</li>
    <li>Login forms</li>
    <li>Quick prototypes</li>
    <li>Forms with few fields</li>
    <li>When form state complexity is low</li>
  </ul>

  <p>❌ <strong>Avoid for:</strong></p>
  <ul>
    <li>Complex validation logic</li>
    <li>Dynamic forms</li>
    <li>Forms needing unit tests</li>
    <li>State management integration</li>
  </ul>

  <hr>

  <h2 id="model-driven-pattern">Model-Driven Pattern</h2>

  <p>Reactive forms where the form model is defined in the component class.</p>

  <h3>Concept</h3>

  <div ngNonBindable><pre><code>┌──────────────────────────────────────────────────────────────┐
│                  MODEL-DRIVEN ARCHITECTURE                    │
└──────────────────────────────────────────────────────────────┘

     Component Class                     Template
    ┌─────────────────┐              ┌─────────────────┐
    │                 │              │                 │
    │  FormGroup &lbrace;    │◄────────────►│ [formGroup]     │
    │    controls: &lbrace;  │  Directive   │                 │
    │      email,     │  Binding     │ formControlName │
    │      password   │              │                 │
    │    &rbrace;            │              │                 │
    │  &rbrace;              │              │                 │
    │                 │              │                 │
    │  • setValue()   │              │ &lt;input&gt;         │
    │  • patchValue() │              │ &lt;select&gt;        │
    │  • reset()      │              │ &lt;button&gt;        │
    │  • valueChanges │              │                 │
    └─────────────────┘              └─────────────────┘
           │
           ▼
    ┌─────────────────┐
    │ Single Source   │
    │ of Truth        │
    │ (Component)     │
    └─────────────────┘</code></pre></div>

  <h3>Implementation</h3>

  <div ngNonBindable><pre><code class="language-typescript">import &lbrace; Component, inject, OnInit, OnDestroy &rbrace; from '&#64;angular/core';
import &lbrace; CommonModule &rbrace; from '&#64;angular/common';
import &lbrace; 
  ReactiveFormsModule, 
  FormBuilder, 
  Validators,
  AbstractControl
&rbrace; from '&#64;angular/forms';
import &lbrace; Subject, takeUntil &rbrace; from 'rxjs';

&#64;Component(&lbrace;
  selector: 'app-registration',
  standalone: true,
  imports: [CommonModule, ReactiveFormsModule],
  template: `
    &lt;form [formGroup]="form" (ngSubmit)="onSubmit()"&gt;
      &lt;div class="form-group"&gt;
        &lt;label&gt;Username&lt;/label&gt;
        &lt;input formControlName="username"&gt;
        @if (username.invalid && username.touched) {
          &lt;div class="errors"&gt;
            @if (username.hasError('required')) {
              &lt;span&gt;Required&lt;/span&gt;
            }
            @if (username.hasError('minlength')) {
              &lt;span&gt;
                Min {{ username.getError('minlength').requiredLength }} characters
              &lt;/span&gt;
            }
          &lt;/div&gt;
        }
      &lt;/div&gt;
      
      &lt;div class="form-group"&gt;
        &lt;label&gt;Email&lt;/label&gt;
        &lt;input formControlName="email" type="email"&gt;
        @if (email.invalid && email.touched) {
          &lt;div class="errors"&gt;
            @if (email.hasError('required')) {
              &lt;span&gt;Required&lt;/span&gt;
            }
            @if (email.hasError('email')) {
              &lt;span&gt;Invalid email&lt;/span&gt;
            }
          &lt;/div&gt;
        }
      &lt;/div&gt;
      
      &lt;div formGroupName="passwords" class="form-group"&gt;
        &lt;label&gt;Password&lt;/label&gt;
        &lt;input formControlName="password" type="password"&gt;
        
        &lt;label&gt;Confirm Password&lt;/label&gt;
        &lt;input formControlName="confirm" type="password"&gt;
        
        @if (passwords.hasError('mismatch')) {
          &lt;div class="errors"&gt;
            Passwords do not match
          &lt;/div&gt;
        }
      &lt;/div&gt;
      
      &lt;button type="submit" [disabled]="form.invalid"&gt;
        Register
      &lt;/button&gt;
    &lt;/form&gt;
  `
&rbrace;)
export class RegistrationComponent implements OnInit, OnDestroy &lbrace;
  private fb = inject(FormBuilder);
  private destroy$ = new Subject&lt;void&gt;();
  
  form = this.fb.group(&lbrace;
    username: ['', [Validators.required, Validators.minLength(3)]],
    email: ['', [Validators.required, Validators.email]],
    passwords: this.fb.group(&lbrace;
      password: ['', [Validators.required, Validators.minLength(8)]],
      confirm: ['', Validators.required]
    &rbrace;, &lbrace; validators: this.passwordMatchValidator &rbrace;)
  &rbrace;);
  
  // Getters for easy template access
  get username() &lbrace; return this.form.get('username')!; &rbrace;
  get email() &lbrace; return this.form.get('email')!; &rbrace;
  get passwords() &lbrace; return this.form.get('passwords')!; &rbrace;
  
  ngOnInit() &lbrace;
    // React to form changes
    this.form.valueChanges.pipe(
      takeUntil(this.destroy$)
    ).subscribe(value =&gt; &lbrace;
      console.log('Form changed:', value);
    &rbrace;);
  &rbrace;
  
  ngOnDestroy() &lbrace;
    this.destroy$.next();
    this.destroy$.complete();
  &rbrace;
  
  passwordMatchValidator(group: AbstractControl) &lbrace;
    const password = group.get('password')?.value;
    const confirm = group.get('confirm')?.value;
    return password === confirm ? null : &lbrace; mismatch: true &rbrace;;
  &rbrace;
  
  onSubmit() &lbrace;
    if (this.form.valid) &lbrace;
      const &lbrace; username, email, passwords &rbrace; = this.form.value;
      console.log('Submitting:', &lbrace; username, email, password: passwords?.password &rbrace;);
    &rbrace;
  &rbrace;
&rbrace;</code></pre></div>

  <h3>Benefits</h3>

  <ul>
    <li><strong>Testability</strong>: Test validation without DOM</li>
    <li><strong>Predictability</strong>: Form state managed in code</li>
    <li><strong>Type Safety</strong>: Full TypeScript support (Angular 14+)</li>
    <li><strong>Complex Validation</strong>: Easy cross-field validators</li>
    <li><strong>Dynamic Control</strong>: Add/remove controls programmatically</li>
  </ul>

  <hr>

  <h2 id="immutability-pattern">Immutability Pattern</h2>

  <p>Treating form state as immutable for predictable state management.</p>

  <h3>Concept</h3>

  <div ngNonBindable><pre><code>┌──────────────────────────────────────────────────────────────┐
│                   IMMUTABILITY PATTERN                        │
└──────────────────────────────────────────────────────────────┘

  ┌─────────────┐                      ┌─────────────┐
  │ State V1    │                      │ State V2    │
  │ &lbrace; name: 'A' &rbrace;│ ───── setValue ────►│ &lbrace; name: 'B' &rbrace;│
  └─────────────┘    (new object)      └─────────────┘
        │                                     │
        │  Original                           │  New reference
        │  unchanged                          │  triggers change
        │                                     │  detection
        ▼                                     ▼
  Can compare                           OnPush works
  references                            efficiently</code></pre></div>

  <h3>Implementation with Signals (Angular 16+)</h3>

  <div ngNonBindable><pre><code class="language-typescript">import &lbrace; Component, computed, signal, inject &rbrace; from '&#64;angular/core';
import &lbrace; ReactiveFormsModule, FormBuilder, Validators &rbrace; from '&#64;angular/forms';

interface UserFormData &lbrace;
  name: string;
  email: string;
  role: string;
&rbrace;

&#64;Component(&lbrace;
  selector: 'app-immutable-form',
  standalone: true,
  imports: [ReactiveFormsModule],
  template: &#96;
    &lt;form [formGroup]="form" (ngSubmit)="save()"&gt;
      &lt;input formControlName="name" placeholder="Name"&gt;
      &lt;input formControlName="email" placeholder="Email"&gt;
      &lt;select formControlName="role"&gt;
        &lt;option value="user"&gt;User&lt;/option&gt;
        &lt;option value="admin"&gt;Admin&lt;/option&gt;
      &lt;/select&gt;
      
      &lt;div class="actions"&gt;
        &lt;button type="submit" [disabled]="!hasChanges()"&gt;Save&lt;/button&gt;
        &lt;button type="button" (click)="revert()"&gt;Revert&lt;/button&gt;
      &lt;/div&gt;
      
      &lt;div class="status"&gt;
        &lt;p&gt;Original: &lbrace;&lbrace; originalData() | json &rbrace;&rbrace;&lt;/p&gt;
        &lt;p&gt;Current: &lbrace;&lbrace; currentData() | json &rbrace;&rbrace;&lt;/p&gt;
        &lt;p&gt;Has Changes: &lbrace;&lbrace; hasChanges() &rbrace;&rbrace;&lt;/p&gt;
      &lt;/div&gt;
    &lt;/form&gt;
  &#96;
&rbrace;)
export class ImmutableFormComponent &lbrace;
  private fb = inject(FormBuilder);
  
  // Original data (immutable reference)
  originalData = signal&lt;UserFormData&gt;(&lbrace;
    name: 'John Doe',
    email: 'john&#64;example.com',
    role: 'user'
  &rbrace;);
  
  form = this.fb.nonNullable.group(&lbrace;
    name: [this.originalData().name, Validators.required],
    email: [this.originalData().email, [Validators.required, Validators.email]],
    role: [this.originalData().role]
  &rbrace;);
  
  // Current form data as signal
  currentData = signal&lt;UserFormData&gt;(this.form.getRawValue());
  
  // Computed signal for change detection
  hasChanges = computed(() =&gt; &lbrace;
    const original = this.originalData();
    const current = this.currentData();
    return JSON.stringify(original) !== JSON.stringify(current);
  &rbrace;);
  
  constructor() &lbrace;
    // Update current data signal on form changes
    this.form.valueChanges.subscribe(value =&gt; &lbrace;
      this.currentData.set(value as UserFormData);
    &rbrace;);
  &rbrace;
  
  save() &lbrace;
    if (this.form.valid &amp;&amp; this.hasChanges()) &lbrace;
      const newData = this.form.getRawValue();
      
      // Create new immutable reference
      this.originalData.set(&lbrace; ...newData &rbrace;);
      
      console.log('Saved:', newData);
    &rbrace;
  &rbrace;
  
  revert() &lbrace;
    // Reset to original immutable state
    this.form.reset(this.originalData());
  &rbrace;
&rbrace;</code></pre></div>

  <h3>NgRx Integration</h3>

  <div ngNonBindable><pre><code class="language-typescript">import &lbrace; Component, inject &rbrace; from '&#64;angular/core';
import &lbrace; Store &rbrace; from '&#64;ngrx/store';
import &lbrace; FormBuilder, Validators &rbrace; from '&#64;angular/forms';
import &lbrace; selectUserData &rbrace; from './store/user.selectors';
import &lbrace; UserActions &rbrace; from './store/user.actions';

&#64;Component(&lbrace;
  selector: 'app-ngrx-form',
  template: &#96;
    &lt;form [formGroup]="form" (ngSubmit)="submit()"&gt;
      &lt;input formControlName="name"&gt;
      &lt;input formControlName="email"&gt;
      &lt;button type="submit"&gt;Update&lt;/button&gt;
    &lt;/form&gt;
  &#96;
&rbrace;)
export class NgrxFormComponent &lbrace;
  private store = inject(Store);
  private fb = inject(FormBuilder);
  
  form = this.fb.group(&lbrace;
    name: ['', Validators.required],
    email: ['', [Validators.required, Validators.email]]
  &rbrace;);
  
  constructor() &lbrace;
    // Populate form from store (immutable)
    this.store.select(selectUserData).subscribe(userData =&gt; &lbrace;
      if (userData) &lbrace;
        this.form.patchValue(userData, &lbrace; emitEvent: false &rbrace;);
      &rbrace;
    &rbrace;);
  &rbrace;
  
  submit() &lbrace;
    if (this.form.valid) &lbrace;
      // Dispatch action with new immutable state
      this.store.dispatch(UserActions.updateUser(&lbrace; 
        user: &lbrace; ...this.form.value &rbrace; 
      &rbrace;));
    &rbrace;
  &rbrace;
&rbrace;</code></pre></div>

  <hr>

  <h2 id="dynamic-forms-pattern">Dynamic Forms Pattern</h2>

  <p>Generate forms from configuration at runtime.</p>

  <h3>Configuration Interface</h3>

  <div ngNonBindable><pre><code class="language-typescript">interface FormFieldConfig &lbrace;
  key: string;
  type: 'text' | 'email' | 'number' | 'select' | 'checkbox' | 'textarea';
  label: string;
  value?: any;
  required?: boolean;
  validators?: ValidatorFn[];
  options?: &lbrace; value: any; label: string &rbrace;[];  // For select
  placeholder?: string;
  disabled?: boolean;
  order?: number;
&rbrace;

interface FormConfig &lbrace;
  title: string;
  fields: FormFieldConfig[];
  submitLabel?: string;
&rbrace;</code></pre></div>

  <h3>Dynamic Form Service</h3>

  <div ngNonBindable><pre><code class="language-typescript">import &lbrace; Injectable &rbrace; from '&#64;angular/core';
import &lbrace; FormBuilder, FormGroup, Validators, ValidatorFn &rbrace; from '&#64;angular/forms';

&#64;Injectable(&lbrace; providedIn: 'root' &rbrace;)
export class DynamicFormService &lbrace;
  constructor(private fb: FormBuilder) &lbrace;&rbrace;
  
  createForm(config: FormFieldConfig[]): FormGroup &lbrace;
    const group: &lbrace; [key: string]: any &rbrace; = &lbrace;&rbrace;;
    
    config.forEach(field =&gt; &lbrace;
      const validators = this.getValidators(field);
      group[field.key] = [
        &lbrace; value: field.value ?? '', disabled: field.disabled ?? false &rbrace;,
        validators
      ];
    &rbrace;);
    
    return this.fb.group(group);
  &rbrace;
  
  private getValidators(field: FormFieldConfig): ValidatorFn[] &lbrace;
    const validators: ValidatorFn[] = [];
    
    if (field.required) &lbrace;
      validators.push(Validators.required);
    &rbrace;
    
    if (field.type === 'email') &lbrace;
      validators.push(Validators.email);
    &rbrace;
    
    if (field.validators) &lbrace;
      validators.push(...field.validators);
    &rbrace;
    
    return validators;
  &rbrace;
&rbrace;</code></pre></div>

  <h3>Dynamic Form Component</h3>

  <pre><code class="language-typescript">import { Component, Input, Output, EventEmitter, inject, OnChanges } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ReactiveFormsModule, FormGroup } from '@angular/forms';
import { DynamicFormService } from './dynamic-form.service';

@Component({
  selector: 'app-dynamic-form',
  standalone: true,
  imports: [CommonModule, ReactiveFormsModule],
  template: `
    &lt;form [formGroup]="form" (ngSubmit)="onSubmit()"&gt;
      &lt;h2&gt;{{ config.title }}&lt;/h2&gt;
      
      @for (field of sortedFields; track field.key) {
        &lt;div class="form-field"&gt;
          &lt;label [for]="field.key"&gt;{{ field.label }}&lt;/label&gt;
          
          &lt;!-- Text, Email, Number inputs --&gt;
          @if (['text', 'email', 'number'].includes(field.type)) {
            &lt;input 
              [id]="field.key"
              [formControlName]="field.key"
              [type]="field.type"
              [placeholder]="field.placeholder || ''"
            &gt;
          }
          
          &lt;!-- Select dropdown --&gt;
          @if (field.type === 'select') {
            &lt;select [id]="field.key" [formControlName]="field.key"&gt;
              &lt;option value=""&gt;Select...&lt;/option&gt;
              @for (opt of field.options; track opt.value) {
                &lt;option [value]="opt.value"&gt;
                  {{ opt.label }}
                &lt;/option&gt;
              }
            &lt;/select&gt;
          }
          
          &lt;!-- Textarea --&gt;
          @if (field.type === 'textarea') {
            &lt;textarea 
              [id]="field.key" 
              [formControlName]="field.key"
              [placeholder]="field.placeholder || ''"
            &gt;&lt;/textarea&gt;
          }
          
          &lt;!-- Checkbox --&gt;
          @if (field.type === 'checkbox') {
            &lt;input 
              type="checkbox" 
              [id]="field.key" 
              [formControlName]="field.key"
            &gt;
          }
          
          &lt;!-- Validation errors --&gt;
          @if (isInvalid(field.key)) {
            &lt;div class="error"&gt;
              @if (hasError(field.key, 'required')) {
                &lt;span&gt;{{ field.label }} is required&lt;/span&gt;
              }
              @if (hasError(field.key, 'email')) {
                &lt;span&gt;Invalid email format&lt;/span&gt;
              }
            &lt;/div&gt;
          }
        &lt;/div&gt;
      }
      &lt;/div&gt;
      
      &lt;button type="submit" [disabled]="form.invalid"&gt;
        &lbrace;&lbrace; config.submitLabel || 'Submit' &rbrace;&rbrace;
      &lt;/button&gt;
    &lt;/form&gt;
  &#96;
&rbrace;)
export class DynamicFormComponent implements OnChanges &lbrace;
  &#64;Input() config!: FormConfig;
  &#64;Output() formSubmit = new EventEmitter&lt;any&gt;();
  
  private dynamicFormService = inject(DynamicFormService);
  
  form!: FormGroup;
  
  get sortedFields(): FormFieldConfig[] &lbrace;
    return [...this.config.fields].sort((a, b) =&gt; 
      (a.order ?? 0) - (b.order ?? 0)
    );
  &rbrace;
  
  ngOnChanges() &lbrace;
    if (this.config) &lbrace;
      this.form = this.dynamicFormService.createForm(this.config.fields);
    &rbrace;
  &rbrace;
  
  isInvalid(key: string): boolean &lbrace;
    const control = this.form.get(key);
    return control ? control.invalid &amp;&amp; control.touched : false;
  &rbrace;
  
  hasError(key: string, error: string): boolean &lbrace;
    return this.form.get(key)?.hasError(error) ?? false;
  &rbrace;
  
  onSubmit() &lbrace;
    if (this.form.valid) &lbrace;
      this.formSubmit.emit(this.form.value);
    &rbrace;
  &rbrace;
&rbrace;</code></pre></div>

  <h3>Usage</h3>

  <div ngNonBindable><pre><code class="language-typescript">&#64;Component(&lbrace;
  selector: 'app-survey',
  template: &#96;
    &lt;app-dynamic-form 
      [config]="surveyConfig" 
      (formSubmit)="onSurveySubmit($event)"
    &gt;&lt;/app-dynamic-form&gt;
  &#96;
&rbrace;)
export class SurveyComponent &lbrace;
  surveyConfig: FormConfig = &lbrace;
    title: 'Customer Survey',
    submitLabel: 'Submit Survey',
    fields: [
      &lbrace; 
        key: 'name', 
        type: 'text', 
        label: 'Full Name', 
        required: true,
        order: 1
      &rbrace;,
      &lbrace; 
        key: 'email', 
        type: 'email', 
        label: 'Email Address', 
        required: true,
        order: 2
      &rbrace;,
      &lbrace; 
        key: 'satisfaction', 
        type: 'select', 
        label: 'Satisfaction Level',
        options: [
          &lbrace; value: 1, label: 'Very Unsatisfied' &rbrace;,
          &lbrace; value: 2, label: 'Unsatisfied' &rbrace;,
          &lbrace; value: 3, label: 'Neutral' &rbrace;,
          &lbrace; value: 4, label: 'Satisfied' &rbrace;,
          &lbrace; value: 5, label: 'Very Satisfied' &rbrace;
        ],
        required: true,
        order: 3
      &rbrace;,
      &lbrace; 
        key: 'comments', 
        type: 'textarea', 
        label: 'Additional Comments',
        placeholder: 'Tell us more...',
        order: 4
      &rbrace;,
      &lbrace; 
        key: 'subscribe', 
        type: 'checkbox', 
        label: 'Subscribe to updates',
        value: false,
        order: 5
      &rbrace;
    ]
  &rbrace;;
  
  onSurveySubmit(data: any) &lbrace;
    console.log('Survey submitted:', data);
  &rbrace;
&rbrace;</code></pre></div>

  <hr>

  <h2 id="multi-step-forms-pattern">Multi-Step Forms Pattern</h2>

  <p>Break complex forms into manageable steps.</p>

  <h3>Step Configuration</h3>

  <div ngNonBindable><pre><code class="language-typescript">interface FormStep &lbrace;
  id: string;
  title: string;
  fields: FormFieldConfig[];
  isValid?: () =&gt; boolean;
&rbrace;

interface WizardConfig &lbrace;
  steps: FormStep[];
  allowSkip?: boolean;
  showProgress?: boolean;
&rbrace;</code></pre></div>

  <h3>Multi-Step Form Component</h3>

  <pre><code class="language-typescript">import { Component, inject, Input, Output, EventEmitter } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ReactiveFormsModule, FormGroup, FormBuilder, Validators } from '@angular/forms';

@Component({
  selector: 'app-multi-step-form',
  standalone: true,
  imports: [CommonModule, ReactiveFormsModule],
  template: `
    &lt;!-- Progress indicator --&gt;
    &lt;div class="progress"&gt;
      @for (step of steps; track step; let i = $index) {
        &lt;div 
          class="step"
          [class.active]="i === currentStep"
          [class.completed]="i &lt; currentStep"
          (click)="goToStep(i)"
        &gt;
          &lt;span class="number"&gt;{{ i + 1 }}&lt;/span&gt;
          &lt;span class="title"&gt;{{ step.title }}&lt;/span&gt;
        &lt;/div&gt;
      }
    &lt;/div&gt;
    
    &lt;!-- Form --&gt;
    &lt;form [formGroup]="form"&gt;
      &lt;!-- Step 1: Personal Info --&gt;
      @if (currentStep === 0) {
        &lt;div class="step-content"&gt;
          &lt;h3&gt;Personal Information&lt;/h3&gt;
          &lt;div formGroupName="personal"&gt;
            &lt;label&gt;First Name&lt;/label&gt;
            &lt;input formControlName="firstName"&gt;
            
            &lt;label&gt;Last Name&lt;/label&gt;
            &lt;input formControlName="lastName"&gt;
            
            &lt;label&gt;Email&lt;/label&gt;
            &lt;input formControlName="email" type="email"&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      }
      
      &lt;!-- Step 2: Address --&gt;
      @if (currentStep === 1) {
        &lt;div class="step-content"&gt;
          &lt;h3&gt;Address&lt;/h3&gt;
          &lt;div formGroupName="address"&gt;
            &lt;label&gt;Street&lt;/label&gt;
            &lt;input formControlName="street"&gt;
          
          &lt;label&gt;City&lt;/label&gt;
          &lt;input formControlName="city"&gt;
          
          &lt;label&gt;Zip Code&lt;/label&gt;
          &lt;input formControlName="zip"&gt;
        &lt;/div&gt;
      &lt;/div&gt;
      }
      
      &lt;!-- Step 3: Review --&gt;
      @if (currentStep === 2) {
        &lt;div class="step-content"&gt;
          &lt;h3&gt;Review Your Information&lt;/h3&gt;
          &lt;pre&gt;{{ form.value | json }}&lt;/pre&gt;
        &lt;/div&gt;
      }
      
      &lt;!-- Navigation --&gt;
      &lt;div class="navigation"&gt;
        &lt;button 
          type="button" 
          (click)="previousStep()" 
          [disabled]="currentStep === 0"
        &gt;
          Previous
        &lt;/button&gt;
        
        &lt;button 
          *ngIf="currentStep &lt; steps.length - 1"
          type="button" 
          (click)="nextStep()" 
          [disabled]="!isCurrentStepValid()"
        &gt;
          Next
        &lt;/button&gt;
        
        &lt;button 
          *ngIf="currentStep === steps.length - 1"
          type="button" 
          (click)="submit()"
          [disabled]="form.invalid"
        &gt;
          Submit
        &lt;/button&gt;
      &lt;/div&gt;
    &lt;/form&gt;
  &#96;
&rbrace;)
export class MultiStepFormComponent &lbrace;
  &#64;Output() formComplete = new EventEmitter&lt;any&gt;();
  
  private fb = inject(FormBuilder);
  
  currentStep = 0;
  
  steps = [
    &lbrace; id: 'personal', title: 'Personal Info' &rbrace;,
    &lbrace; id: 'address', title: 'Address' &rbrace;,
    &lbrace; id: 'review', title: 'Review' &rbrace;
  ];
  
  form = this.fb.group(&lbrace;
    personal: this.fb.group(&lbrace;
      firstName: ['', Validators.required],
      lastName: ['', Validators.required],
      email: ['', [Validators.required, Validators.email]]
    &rbrace;),
    address: this.fb.group(&lbrace;
      street: ['', Validators.required],
      city: ['', Validators.required],
      zip: ['', [Validators.required, Validators.pattern(/^\d&lbrace;5&rbrace;$/)]]
    &rbrace;)
  &rbrace;);
  
  isCurrentStepValid(): boolean &lbrace;
    const stepKeys = ['personal', 'address'];
    const currentKey = stepKeys[this.currentStep];
    
    if (!currentKey) return true; // Review step
    
    const group = this.form.get(currentKey) as FormGroup;
    return group?.valid ?? true;
  &rbrace;
  
  nextStep() &lbrace;
    if (this.isCurrentStepValid() &amp;&amp; this.currentStep &lt; this.steps.length - 1) &lbrace;
      this.currentStep++;
    &rbrace;
  &rbrace;
  
  previousStep() &lbrace;
    if (this.currentStep &gt; 0) &lbrace;
      this.currentStep--;
    &rbrace;
  &rbrace;
  
  goToStep(step: number) &lbrace;
    // Only allow going to completed or current steps
    if (step &lt;= this.currentStep) &lbrace;
      this.currentStep = step;
    &rbrace;
  &rbrace;
  
  submit() &lbrace;
    if (this.form.valid) &lbrace;
      this.formComplete.emit(this.form.value);
    &rbrace;
  &rbrace;
&rbrace;</code></pre></div>

  <hr>

  <h2 id="form-factory-pattern">Form Factory Pattern</h2>

  <p>Encapsulate form creation logic in reusable services.</p>

  <h3>Form Factory Service</h3>

  <div ngNonBindable><pre><code class="language-typescript">import &lbrace; Injectable, inject &rbrace; from '&#64;angular/core';
import &lbrace; FormBuilder, FormGroup, Validators, AbstractControl &rbrace; from '&#64;angular/forms';

&#64;Injectable(&lbrace; providedIn: 'root' &rbrace;)
export class FormFactoryService &lbrace;
  private fb = inject(FormBuilder);
  
  // User registration form
  createRegistrationForm(data?: Partial&lt;UserRegistration&gt;): FormGroup &lbrace;
    return this.fb.group(&lbrace;
      username: [data?.username ?? '', [
        Validators.required,
        Validators.minLength(3),
        Validators.maxLength(20)
      ]],
      email: [data?.email ?? '', [
        Validators.required,
        Validators.email
      ]],
      password: [data?.password ?? '', [
        Validators.required,
        Validators.minLength(8)
      ]],
      confirmPassword: ['', Validators.required],
      terms: [false, Validators.requiredTrue]
    &rbrace;, &lbrace;
      validators: this.passwordMatchValidator
    &rbrace;);
  &rbrace;
  
  // Address subform
  createAddressForm(data?: Partial&lt;Address&gt;): FormGroup &lbrace;
    return this.fb.group(&lbrace;
      street: [data?.street ?? '', Validators.required],
      city: [data?.city ?? '', Validators.required],
      state: [data?.state ?? '', Validators.required],
      zip: [data?.zip ?? '', [
        Validators.required,
        Validators.pattern(/^\d&lbrace;5&rbrace;(-\d&lbrace;4&rbrace;)?$/)
      ]],
      country: [data?.country ?? 'US']
    &rbrace;);
  &rbrace;
  
  // Order form with nested address
  createOrderForm(data?: Partial&lt;Order&gt;): FormGroup &lbrace;
    return this.fb.group(&lbrace;
      orderNumber: [data?.orderNumber ?? this.generateOrderNumber()],
      customer: this.fb.group(&lbrace;
        name: [data?.customer?.name ?? '', Validators.required],
        email: [data?.customer?.email ?? '', [Validators.required, Validators.email]],
        phone: [data?.customer?.phone ?? '']
      &rbrace;),
      shippingAddress: this.createAddressForm(data?.shippingAddress),
      billingAddress: this.createAddressForm(data?.billingAddress),
      sameAsShipping: [true],
      items: this.fb.array([]),
      notes: ['']
    &rbrace;);
  &rbrace;
  
  // Validators
  private passwordMatchValidator(group: AbstractControl) &lbrace;
    const password = group.get('password')?.value;
    const confirm = group.get('confirmPassword')?.value;
    return password === confirm ? null : &lbrace; passwordMismatch: true &rbrace;;
  &rbrace;
  
  private generateOrderNumber(): string &lbrace;
    return &#96;ORD-$&lbrace;Date.now()&rbrace;&#96;;
  &rbrace;
&rbrace;</code></pre></div>

  <h3>Using the Factory</h3>

  <div ngNonBindable><pre><code class="language-typescript">&#64;Component(&lbrace;
  selector: 'app-checkout',
  template: &#96;
    &lt;form [formGroup]="orderForm" (ngSubmit)="placeOrder()"&gt;
      &lt;!-- Customer info --&gt;
      &lt;section formGroupName="customer"&gt;
        &lt;h3&gt;Customer Information&lt;/h3&gt;
        &lt;input formControlName="name" placeholder="Name"&gt;
        &lt;input formControlName="email" placeholder="Email"&gt;
        &lt;input formControlName="phone" placeholder="Phone"&gt;
      &lt;/section&gt;
      
      &lt;!-- Shipping address --&gt;
      &lt;section formGroupName="shippingAddress"&gt;
        &lt;h3&gt;Shipping Address&lt;/h3&gt;
        &lt;app-address-fields&gt;&lt;/app-address-fields&gt;
      &lt;/section&gt;
      
      &lt;label&gt;
        &lt;input type="checkbox" formControlName="sameAsShipping"&gt;
        Billing same as shipping
      &lt;/label&gt;
      
      &lt;!-- Billing address (if different) --&gt;
      &lt;section *ngIf="!orderForm.get('sameAsShipping')?.value" formGroupName="billingAddress"&gt;
        &lt;h3&gt;Billing Address&lt;/h3&gt;
        &lt;app-address-fields&gt;&lt;/app-address-fields&gt;
      &lt;/section&gt;
      
      &lt;button type="submit" [disabled]="orderForm.invalid"&gt;Place Order&lt;/button&gt;
    &lt;/form&gt;
  &#96;
&rbrace;)
export class CheckoutComponent &lbrace;
  private formFactory = inject(FormFactoryService);
  
  orderForm = this.formFactory.createOrderForm();
  
  placeOrder() &lbrace;
    if (this.orderForm.valid) &lbrace;
      const order = this.orderForm.value;
      
      // Copy shipping to billing if same
      if (order.sameAsShipping) &lbrace;
        order.billingAddress = &lbrace; ...order.shippingAddress &rbrace;;
      &rbrace;
      
      console.log('Placing order:', order);
    &rbrace;
  &rbrace;
&rbrace;</code></pre></div>

  <hr>

  <h2 id="onpush-optimization">OnPush Optimization</h2>

  <p>Optimize form performance with OnPush change detection.</p>

  <h3>Implementation</h3>

  <div ngNonBindable><pre><code class="language-typescript">import &lbrace; 
  Component, 
  ChangeDetectionStrategy, 
  inject, 
  ChangeDetectorRef 
&rbrace; from '&#64;angular/core';
import &lbrace; ReactiveFormsModule, FormBuilder, Validators &rbrace; from '&#64;angular/forms';
import &lbrace; CommonModule, AsyncPipe &rbrace; from '&#64;angular/common';
import &lbrace; map, startWith &rbrace; from 'rxjs/operators';

&#64;Component(&lbrace;
  selector: 'app-optimized-form',
  standalone: true,
  imports: [CommonModule, ReactiveFormsModule, AsyncPipe],
  changeDetection: ChangeDetectionStrategy.OnPush,  // Key optimization
  template: &#96;
    &lt;form [formGroup]="form" (ngSubmit)="submit()"&gt;
      &lt;input formControlName="name"&gt;
      &lt;input formControlName="email"&gt;
      
      &lt;!-- Use async pipe for automatic updates --&gt;
      &lt;div *ngIf="nameValue$ | async as name"&gt;
        Preview: &lbrace;&lbrace; name &rbrace;&rbrace;
      &lt;/div&gt;
      
      &lt;!-- Status using async pipe --&gt;
      &lt;p&gt;Form Status: &lbrace;&lbrace; status$ | async &rbrace;&rbrace;&lt;/p&gt;
      
      &lt;button 
        type="submit" 
        [disabled]="(isInvalid$ | async)"
      &gt;
        Submit
      &lt;/button&gt;
    &lt;/form&gt;
  &#96;
&rbrace;)
export class OptimizedFormComponent &lbrace;
  private fb = inject(FormBuilder);
  
  form = this.fb.group(&lbrace;
    name: ['', Validators.required],
    email: ['', [Validators.required, Validators.email]]
  &rbrace;);
  
  // Observables for async pipe (triggers change detection automatically)
  nameValue$ = this.form.get('name')!.valueChanges.pipe(
    startWith(this.form.get('name')!.value)
  );
  
  status$ = this.form.statusChanges.pipe(
    startWith(this.form.status)
  );
  
  isInvalid$ = this.form.statusChanges.pipe(
    startWith(this.form.status),
    map(status =&gt; status === 'INVALID')
  );
  
  submit() &lbrace;
    if (this.form.valid) &lbrace;
      console.log('Submitting:', this.form.value);
    &rbrace;
  &rbrace;
&rbrace;</code></pre></div>

  <h3>Best Practices for OnPush</h3>

  <div ngNonBindable><pre><code class="language-typescript">&#64;Component(&lbrace;
  changeDetection: ChangeDetectionStrategy.OnPush
&rbrace;)
export class OnPushFormComponent &lbrace;
  private cdr = inject(ChangeDetectorRef);
  
  // ✓ Use observables with async pipe
  formValue$ = this.form.valueChanges;
  
  // ✓ Or manually trigger change detection when needed
  updateFormExternally(data: any) &lbrace;
    this.form.patchValue(data);
    this.cdr.markForCheck();  // Trigger change detection
  &rbrace;
  
  // ✓ Use immutable updates
  replaceData(newData: FormData) &lbrace;
    this.form.reset(newData);
    this.cdr.markForCheck();
  &rbrace;
&rbrace;</code></pre></div>

  <hr>

  <div style="text-align: center; margin: 2rem 0;">
    <p>
      <a routerLink="/documentation/modules">← Modules</a> | 
      <a routerLink="/documentation">Index</a>
    </p>
  </div>

  
</div>










